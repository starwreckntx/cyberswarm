
// Vulnerability Scanner Agent - Simulated vulnerability detection

import { BaseAgent } from './base-agent';
import { Task, CyberEvent, Vulnerability, EventType, Severity } from '../types';

interface VulnerabilityDatabase {
  cve_id: string;
  description: string;
  severity: Severity;
  affected_ports: number[];
  affected_services: string[];
}

export class VulnerabilityScannerAgent extends BaseAgent {
  private vulnerabilityDb: VulnerabilityDatabase[] = [
    {
      cve_id: "CVE-2021-44228",
      description: "Apache Log4j2 Remote Code Execution",
      severity: "Critical",
      affected_ports: [8080, 8443, 9200],
      affected_services: ["Apache Tomcat", "Elasticsearch"]
    },
    {
      cve_id: "CVE-2021-34527", 
      description: "Windows Print Spooler Remote Code Execution",
      severity: "Critical",
      affected_ports: [135, 445],
      affected_services: ["RPC", "SMB"]
    },
    {
      cve_id: "CVE-2022-0847",
      description: "Dirty Pipe Linux Privilege Escalation",
      severity: "High",
      affected_ports: [22, 80, 443],
      affected_services: ["SSH", "HTTP", "HTTPS"]
    },
    {
      cve_id: "CVE-2021-26855",
      description: "Microsoft Exchange Server Remote Code Execution",
      severity: "Critical",
      affected_ports: [443, 80],
      affected_services: ["Exchange", "HTTP", "HTTPS"]
    },
    {
      cve_id: "CVE-2020-1472",
      description: "Netlogon Elevation of Privilege Vulnerability",
      severity: "Critical",
      affected_ports: [135, 445, 139],
      affected_services: ["RPC", "SMB", "NetBIOS"]
    }
  ];

  constructor() {
    super(
      'vuln-scanner-01',
      'Vulnerability Scanner Agent',
      'VulnerabilityScannerAgent',
      ['vuln_scan', 'config_audit', 'webapp_scan']
    );
  }

  async executeTask(task: Task): Promise<CyberEvent> {
    this.setStatus("BUSY");
    
    try {
      this.logChainOfThought(
        1,
        "analysis",
        "Vulnerability assessment initialization",
        `Starting ${task.taskName} on target ${task.target}. Analyzing available reconnaissance data to focus scanning efforts.`,
        { taskName: task.taskName, target: task.target }
      );

      switch (task.taskName) {
        case 'vuln_scan':
          return await this.vulnerabilityScan(task);
        case 'config_audit':
          return await this.configAudit(task);
        case 'webapp_scan':
          return await this.webAppScan(task);
        default:
          throw new Error(`Unsupported task: ${task.taskName}`);
      }
    } finally {
      this.setStatus("IDLE");
    }
  }

  private async vulnerabilityScan(task: Task): Promise<CyberEvent> {
    const target = task.target || '192.168.1.10';
    const openPorts = task.details?.ports || [22, 80, 443, 8080];

    this.logChainOfThought(
      2,
      "decision",
      "Vulnerability scanning strategy",
      `Analyzing target ${target} with ${openPorts.length} open ports. Cross-referencing with vulnerability database containing ${this.vulnerabilityDb.length} known CVEs. Prioritizing critical vulnerabilities.`,
      { 
        target, 
        openPorts, 
        dbSize: this.vulnerabilityDb.length,
        strategy: "CVE-focused_with_service_correlation"
      }
    );

    await this.simulateNetworkOperation("vulnerability scan", target, 3);

    // Find matching vulnerabilities
    const matchingVulns = this.findMatchingVulnerabilities(openPorts);
    
    this.logChainOfThought(
      3,
      "evaluation",
      "Vulnerability analysis",
      `Vulnerability scan completed. Found ${matchingVulns.length} potential vulnerabilities matching open services. Risk assessment shows ${this.assessOverallRisk(matchingVulns)} risk level.`,
      { 
        scannedPorts: openPorts,
        vulnerabilitiesFound: matchingVulns.length,
        riskLevel: this.assessOverallRisk(matchingVulns),
        criticalCount: matchingVulns.filter(v => v.severity === 'Critical').length
      },
      0.88
    );

    if (matchingVulns.length > 0) {
      // Select the most critical vulnerability
      const selectedVuln = matchingVulns.sort((a, b) => 
        this.getSeverityScore(b.severity) - this.getSeverityScore(a.severity)
      )[0];

      const targetPort = selectedVuln.affected_ports.find(port => 
        openPorts.includes(port)
      ) || openPorts[0];

      this.logChainOfThought(
        4,
        "decision",
        "Vulnerability prioritization",
        `Selected ${selectedVuln.cve_id} as primary target due to ${selectedVuln.severity} severity and service correlation on port ${targetPort}. This vulnerability allows ${selectedVuln.description}.`,
        { 
          selectedCVE: selectedVuln.cve_id,
          severity: selectedVuln.severity,
          targetPort,
          exploitPotential: "Remote Code Execution"
        },
        0.95
      );

      const vulnerability: Vulnerability = {
        cve_id: selectedVuln.cve_id,
        target_ip: target,
        target_port: targetPort,
        severity: selectedVuln.severity,
        description: selectedVuln.description
      };

      return this.emitEvent(
        EventType.VULNERABILITY_FOUND,
        vulnerability,
        selectedVuln.severity,
        target,
        task.taskId
      );
    } else {
      this.logChainOfThought(
        4,
        "evaluation",
        "No vulnerabilities detected",
        `Vulnerability scan complete with no matching CVEs found for detected services. Target appears to be well-patched or using non-standard service configurations.`,
        { reason: "No CVE matches for detected services" },
        0.75
      );

      return this.emitEvent(
        EventType.SCAN_COMPLETE,
        {
          target_ip: target,
          vulnerabilities_found: 0,
          scan_type: 'vulnerability_scan'
        },
        'Low',
        target,
        task.taskId
      );
    }
  }

  private async configAudit(task: Task): Promise<CyberEvent> {
    const target = task.target || '192.168.1.10';

    this.logChainOfThought(
      2,
      "decision", 
      "Configuration audit approach",
      `Performing security configuration audit on ${target}. Checking for common misconfigurations, default credentials, and security policy violations.`,
      { target, auditScope: "security_configurations" }
    );

    await this.simulateNetworkOperation("configuration audit", target, 2);

    const configIssues = this.generateConfigIssues();

    this.logChainOfThought(
      3,
      "evaluation",
      "Configuration audit results",
      `Configuration audit revealed ${configIssues.length} security issues. Priority should be given to ${configIssues.filter(i => i.severity === 'High').length} high-severity findings.`,
      { 
        totalIssues: configIssues.length,
        highSeverity: configIssues.filter(i => i.severity === 'High').length,
        issues: configIssues
      },
      0.82
    );

    return this.emitEvent(
      EventType.CONFIG_AUDIT_COMPLETE,
      {
        target_ip: target,
        issues_found: configIssues.length,
        issues: configIssues,
        scan_type: 'config_audit'
      },
      configIssues.some(i => i.severity === 'High') ? 'High' : 'Medium',
      target,
      task.taskId
    );
  }

  private async webAppScan(task: Task): Promise<CyberEvent> {
    const target = task.target || '192.168.1.10';

    this.logChainOfThought(
      2,
      "decision",
      "Web application security scan",
      `Initiating comprehensive web application security scan on ${target}. Testing for OWASP Top 10 vulnerabilities including injection flaws, broken authentication, and security misconfigurations.`,
      { target, framework: "OWASP_Top_10" }
    );

    await this.simulateNetworkOperation("web application scan", target, 4);

    const webVulns = this.generateWebVulnerabilities();

    this.logChainOfThought(
      3,
      "evaluation", 
      "Web application vulnerability assessment",
      `Web application scan completed. Identified ${webVulns.length} vulnerabilities across different attack vectors. SQL injection and XSS vulnerabilities pose the highest risk.`,
      { 
        vulnerabilities: webVulns,
        riskCategories: ["Injection", "XSS", "Authentication"],
        businessImpact: "Data breach potential"
      },
      0.87
    );

    return this.emitEvent(
      EventType.WEBAPP_SCAN_COMPLETE,
      {
        target_ip: target,
        vulnerabilities: webVulns,
        scan_type: 'webapp_scan'
      },
      webVulns.some(v => v.severity === 'High') ? 'High' : 'Medium',
      target,
      task.taskId
    );
  }

  private findMatchingVulnerabilities(openPorts: number[]): VulnerabilityDatabase[] {
    // 70% chance of finding vulnerabilities for demonstration
    if (Math.random() < 0.7) {
      return this.vulnerabilityDb.filter(vuln => 
        vuln.affected_ports.some(port => openPorts.includes(port))
      );
    }
    return [];
  }

  private getSeverityScore(severity: Severity): number {
    const scores = { Critical: 4, High: 3, Medium: 2, Low: 1 };
    return scores[severity] || 0;
  }

  private assessOverallRisk(vulnerabilities: VulnerabilityDatabase[]): string {
    if (vulnerabilities.some(v => v.severity === 'Critical')) return 'Critical';
    if (vulnerabilities.some(v => v.severity === 'High')) return 'High';
    if (vulnerabilities.length > 0) return 'Medium';
    return 'Low';
  }

  private generateConfigIssues() {
    const possibleIssues = [
      { issue: "Weak SSH configuration", severity: "Medium", description: "SSH allows password authentication" },
      { issue: "Default credentials", severity: "High", description: "Default admin credentials detected" },
      { issue: "Unnecessary services", severity: "Low", description: "Unused services are running" },
      { issue: "Weak SSL/TLS configuration", severity: "Medium", description: "Weak cipher suites enabled" },
      { issue: "Missing security headers", severity: "Medium", description: "HTTP security headers not configured" },
      { issue: "Excessive permissions", severity: "High", description: "Service running with admin privileges" }
    ];

    const numIssues = Math.floor(Math.random() * 4);
    return possibleIssues.slice(0, numIssues);
  }

  private generateWebVulnerabilities() {
    const possibleVulns = [
      { type: "SQL Injection", severity: "High", location: "/login.php", description: "SQL injection in login form" },
      { type: "Cross-Site Scripting (XSS)", severity: "Medium", location: "/search.php", description: "Reflected XSS in search parameter" },
      { type: "Directory Traversal", severity: "High", location: "/download.php", description: "Path traversal vulnerability" },
      { type: "Insecure Direct Object Reference", severity: "Medium", location: "/user/profile.php", description: "IDOR in user profile access" },
      { type: "Command Injection", severity: "Critical", location: "/admin/system.php", description: "OS command injection" },
      { type: "Authentication Bypass", severity: "High", location: "/admin/", description: "Admin panel accessible without authentication" }
    ];

    const numVulns = Math.floor(Math.random() * 3);
    return possibleVulns.slice(0, numVulns);
  }
}

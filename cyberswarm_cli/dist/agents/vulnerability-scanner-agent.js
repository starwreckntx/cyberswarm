// Vulnerability Scanner Agent - Vulnerability detection with Gemini AI
import { BaseAgent } from './base-agent.js';
import { EventType } from '../types.js';
import { PROMPTS } from '../gemini/prompts.js';
import { loadCVEDatabase } from '../utils/file-tools.js';
import { logger } from '../utils/logger.js';
export class VulnerabilityScannerAgent extends BaseAgent {
    cveDatabase;
    constructor(geminiClient) {
        super('vuln-scanner-01', 'Vulnerability Scanner Agent', 'VulnerabilityScannerAgent', ['vuln_scan', 'config_audit', 'webapp_scan'], geminiClient);
        // Load CVE database from file
        this.cveDatabase = loadCVEDatabase();
    }
    async executeTask(task) {
        this.setStatus("BUSY");
        try {
            this.logChainOfThought(1, "analysis", "Analyzing vulnerability scan request", `Received ${task.taskName} task for ${task.target}. Using Gemini AI with CVE database for intelligent vulnerability assessment.`, { taskName: task.taskName, target: task.target, cveCount: this.cveDatabase.length });
            switch (task.taskName) {
                case 'vuln_scan':
                    return await this.vulnerabilityScan(task);
                case 'config_audit':
                    return await this.configAudit(task);
                case 'webapp_scan':
                    return await this.webappScan(task);
                default:
                    throw new Error(`Unsupported task: ${task.taskName}`);
            }
        }
        catch (error) {
            logger.error(`[${this.agentId}] Task execution failed: ${error.message}`);
            this.setStatus("ERROR");
            throw error;
        }
        finally {
            if (this.status !== "ERROR") {
                this.setStatus("IDLE");
            }
        }
    }
    async vulnerabilityScan(task) {
        const target = task.target || '192.168.1.10';
        const services = task.details?.services || {};
        this.logChainOfThought(2, "decision", "Vulnerability assessment strategy", `Consulting Gemini AI to analyze services and identify vulnerabilities for ${target}`, { target, services });
        // Use Gemini to analyze vulnerabilities
        const vulnAnalysis = await this.getGeminiDecision(PROMPTS.VULN_SCANNER(target, services));
        this.logChainOfThought(3, "evaluation", "Vulnerability analysis complete", vulnAnalysis.analysis_summary, {
            total_vulnerabilities: vulnAnalysis.vulnerabilities.length,
            risk_level: vulnAnalysis.risk_summary.overall_risk,
        }, 0.90);
        await this.delay(3000, 5000);
        // Emit event for each critical/high vulnerability
        const criticalVulns = vulnAnalysis.vulnerabilities.filter((v) => v.severity === 'Critical' || v.severity === 'High');
        this.logChainOfThought(4, "action", "Emitting vulnerability events", `Identified ${criticalVulns.length} critical/high severity vulnerabilities requiring immediate attention`, { critical_vulns: criticalVulns.map((v) => v.cve_id) }, 0.85);
        // Emit the most critical vulnerability
        if (criticalVulns.length > 0) {
            const mostCritical = criticalVulns[0];
            const vulnerability = {
                cve_id: mostCritical.cve_id,
                target_ip: target,
                target_port: mostCritical.affected_port,
                severity: mostCritical.severity,
                description: mostCritical.description,
                exploit_available: mostCritical.exploit_available,
                cvss_score: mostCritical.cvss_score,
            };
            return this.emitEvent(EventType.VULNERABILITY_FOUND, {
                ...vulnerability,
                all_vulnerabilities: vulnAnalysis.vulnerabilities,
                risk_summary: vulnAnalysis.risk_summary,
            }, mostCritical.severity, target, task.taskId);
        }
        // No critical vulnerabilities found
        return this.emitEvent(EventType.SCAN_COMPLETE, {
            target,
            vulnerabilities: vulnAnalysis.vulnerabilities,
            risk_summary: vulnAnalysis.risk_summary,
        }, 'Low', target, task.taskId);
    }
    async configAudit(task) {
        const target = task.target || '192.168.1.10';
        this.logChainOfThought(2, "analysis", "Configuration audit", `Auditing system configuration for ${target} using Gemini AI`, { target });
        await this.delay(2000, 4000);
        // Use Gemini for configuration analysis
        const configAnalysis = await this.getGeminiDecision(`You are auditing system configuration for ${target}. Analyze for security misconfigurations and weaknesses. Return JSON with findings.`);
        this.logChainOfThought(3, "evaluation", "Configuration audit complete", `Identified configuration issues and recommendations`, { findings: configAnalysis }, 0.80);
        return this.emitEvent(EventType.CONFIG_AUDIT_COMPLETE, configAnalysis, 'Medium', target, task.taskId);
    }
    async webappScan(task) {
        const target = task.target || 'http://192.168.1.10';
        this.logChainOfThought(2, "analysis", "Web application scan", `Scanning web application at ${target} for common vulnerabilities`, { target });
        await this.delay(3000, 6000);
        // Use Gemini for web app analysis
        const webappAnalysis = await this.getGeminiDecision(`Analyze web application at ${target} for OWASP Top 10 vulnerabilities. Return JSON with findings.`);
        this.logChainOfThought(3, "evaluation", "Web application scan complete", `Identified potential web vulnerabilities`, { findings: webappAnalysis }, 0.75);
        return this.emitEvent(EventType.WEBAPP_SCAN_COMPLETE, webappAnalysis, 'Medium', target, task.taskId);
    }
}
//# sourceMappingURL=vulnerability-scanner-agent.js.map